1.	什么是垃圾收集器
垃圾收集器（GC）可以自动管理应用的动态内存分配请求。
垃圾收集器通过以下操作进行动态内存管理：
	从操作系统中分配和回收内存
	当应用请求分配内存时分配给它
	确定哪些内存仍然被应用使用
	回收未使用的内存以供应用程序重用

Java Hotspot垃圾收集器使用不同的技术提升上述操作的效率：
	使用分代回收结合年龄，把注意力集中在最可能有大量可回收内存的区域----堆。
	使用多个线程并行操作，或者在应用后台并发执行一些长运行的操作。
	通过整理存活的对象，尽可能恢复出更大连续可用内存。

2.	为什么垃圾收集器的选择很重要？
垃圾收集器的目的就是把应用开发者从手动管理内存中释放出来。开发者不需要分配和释放内存，也不需要关心分配的动态内存的生命周期。这样做可以避免一些由于内存管理不当导致的错误。

3.	一些默认的选择
These are important garbage collector, heap size, and runtime compiler default
selections:
• Garbage-First (G1) collector
• The maximum number of GC threads is limited by heap size and available CPU
resources
• Initial heap size of 1/64 of physical memory
• Maximum heap size of 1/4 of physical memory
• Tiered compiler, using both C1 and C2

4.	基于行为的调优
两大目标：暂停时间（pause-time）和吞吐量（application throughput）。
当一个目标达到了，垃圾收集器会尽可能最优化另外一个。自然，这两个目标总是不能同时满足。
	Pause-Time Goal
暂停时间是指：垃圾收集器停止应用程序，回收不再被使用的内存空间这段时间。
如果平均暂停时间加上方差，大于暂停时间的目标，则认为目标没有达成。
可以通过命令行参数：-XX:MaxGCPauseMillis=<nnn>配置
调整这个参数可能导致：垃圾收集更频繁的出现，减少应用的吞吐量。

	Throughput Goal
The goal is specified by the command-line option -XX:GCTimeRatio=nnn. The ratio of
garbage collection time to application time is 1/ (1+nnn). For example, -XX:GCTimeRatio=19 sets a goal of 1/20th or 5% of the total time for garbage collection
垃圾收集的时间是：所有垃圾收集引发的暂停时间总和。
如果吞吐量目标没有达到，垃圾收集器可能会增加堆空间，这样做才可以让两次垃圾收集暂停之间的应用时间变长。

5.	调优策略
不要为堆选择一个最大值，除非你知道你的堆空间需要大于默认的最大堆空间。
应用的行为可以导致堆空间增加或减少。例如，如果应用开始以更高的速率分配空间，那么堆空间会增加以维持吞吐量不变。
如果堆空间增加到他的最大值，并且吞吐量的目标还是没有达到，则设置的最大堆空间对于吞吐量目标来说太小了。这种情况可以设置最大堆空间大小接近于物理内存大小，但是确保不要引发应用swapping。再次执行应用，如果吞吐量目标还是没有达到，则说明吞吐量目标定得太高了。
如果吞吐量目标已经满足了，但是暂停太长时间，之后选择暂停时间作为目标。这就意味着吞吐量的目标将不会满足，这种情况可以选择一个应用可以接受的值。


二、影响垃圾收集性能的因素
1.Total Heap
影响垃圾收集性能最重要的因素就是总的可用内存。因为垃圾收集出现在每个代空间装满时，吞吐量与可用内存成反比。
2.The Young Generation
第二个影响垃圾收集性能的是年轻代的大小
年轻代越大，minor GC的频率越低。然而，对于一个固定大小的堆空间，更大的年轻代空间意味着更小的老年代空间，这将会增加major GC的频率。最优的选择依赖应用分配的对象生命周期分布情况。
年轻代大小是通过-XX:NewRatio 控制的。
例如-XX:NewRatio=3意味着，年轻代：老年代=1:3。换句话说就是Eden区加上survivor区是整个堆空间的四分之一。
