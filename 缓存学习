1.为什么用缓存？
1）高性能；对于不经常发生改变的数据，并且查询耗时，可以避免大量请求直接到MySQL中，造成性能问题。可以通过一次MySQL操作，
之后缓存起来，接下来的查询就走缓存，减轻数据库的压力，并且大部分的缓存中间件都工作在内存中，性能较高，提高性能。
2）高并发：redis等缓存可以支持很高的并发

2.使用缓存会产生的问题？
1）缓存和数据库的数据不一致性
2）缓存雪崩
3）缓存穿透
4）缓存击穿

3.为什么redis单线程效率这么高？
1）纯内存操作
2）核心是基于非阻塞的IO多路复用机制
3）单线程反而避免了多线程的频繁上下文切换问题。

4.redis过期策略？
定期删除+惰性删除
定期删除：redis每隔100ms随即抽取一些设置了过期时间的key，检查其是否过期，如果过期就删除。
惰性删除：定期删除可能会导致很多过期key到了时间并没有被删除掉。这个时候还有惰性删除，就是在获取key的时候，redis
会检查一下这个key是否过期，如果过期会删除。

**但实际上可能还会有问题，如果定期删除漏掉了很多过期key，然后也没及时去查，也就是没走惰性删除，如果大量过期key堆积在
内存里，导致redis内存耗尽。这个时候还有内存淘汰机制：
5.内存淘汰
lru
随即删除key


redis的线程模型：
1）文件事件处理器
redis基于reactor模式开发了网络事件处理器，这个处理器叫做文件事件处理器。采用IO多路复用机制同时监听多个socket，根据socket上的事件
来选择对应的事件处理器来处理这个事件。
如果被监听的socket准备好执行accept、read、write、close等操作的时候，跟操作对应的文件事件就会产生，这个时候文件处理器就会调用之前关联好的
事件处理器来处理这个事件。
文件事件处理器是单线程模式运行的，但是通过IO多路复用机制监听多个socket，可以实现高性能的网络通信模型，又可以跟内部
其他单线程的模块进行对接，保证了redis内部的线程模型的简单性。
文件事件处理器包含4个部分：多个socket，IO多路复用程序，文件事件分派器，事件处理器（命令请求处理器、命令回复处理器、连接应答处理器等）
多个socket可能并发的产生不同的操作，每个操作对应不同的文件事件，但是IO多路复用程序会监听多个socket，会将socket放入
一个队列中排队，每次从队列中取出一个socket给事件分派器，事件分派器把socket给对应的事件处理器。
然后一个socket的事件处理完成之后，IO多路复用程序才会将队列中的下一个socket给事件分派器。文件事件分派器会根据每个socket
当前产生的事件，来选择对应的事件处理器来处理。
